"use strict";(()=>{var L=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var d=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var _=d((Sn,D)=>{function qe(e){return Array.from(e).map(t=>t.toString(16).padStart(2,"0").toUpperCase()).join(":")}function Le(e){return e.join(".")}function De(e){let t=e.split(":").map(n=>parseInt(n,16));return Buffer.from(t)}function _e(e){let t=e.split(".").map(n=>parseInt(n,10));return Buffer.from(t)}D.exports={readMAC:qe,readIP:Le,processIP:_e,processMAC:De}});var j=d((yn,V)=>{var{readMAC:M,readIP:$,processIP:z,processMAC:W}=_();function Me(e,t,n,r,o,s,c,i,f){let u=Buffer.alloc(28);u.writeUInt16BE(e,0),u.writeUInt16BE(t,2),u.writeUInt8(n,4),u.writeUInt8(r,5),u.writeUInt16BE(o,6);let m=W(s),p=z(c),l=W(i),B=z(f);return m.copy(u,8),p.copy(u,14),l.copy(u,18),B.copy(u,24),console.log(u),u}function $e(e){let t={};return t.hType=e.readUInt16BE(0),t.pType=e.readUInt16BE(2),t.hLen=e.readUInt8(4),t.pLen=e.readUInt8(5),t.oper=e.readUInt16BE(6),t.senderMAC=M(e.subarray(8,14)),t.senderIP=$(e.subarray(14,18)),t.targetMAC=M(e.subarray(18,24)),t.targetIP=$(e.subarray(24,28)),t}V.exports={Encode:Me,Decode:$e}});var Y=d((xn,K)=>{function ze(e){if(e===".")return Buffer.from([0]);let t=[];return e.split(".").forEach(n=>{if(n.length>63)throw new Error("Label too long");t.push(n.length);for(let r of n)t.push(r.charCodeAt(0))}),t.push(0),Buffer.from(t)}function We(e){return{qr:e>>15&1,opcode:e>>11&15,aa:e>>10&1,tc:e>>9&1,rd:e>>8&1,ra:e>>7&1,z:e>>4&7,rcode:e&15}}function Ve(e){return e.qr<<15|e.opcode<<11|e.aa<<10|e.tc<<9|e.rd<<8|e.ra<<7|e.z<<4|e.rcode}K.exports={encodeDomainName:ze,parseFlags:We,encodeFlags:Ve}});var Q=d((Pn,k)=>{var je={A:1,NS:2,CNAME:5,SOA:6,MX:15,TXT:16,AAAA:28},Ke={IN:1,CS:2,CH:3,HS:4},Ye={QUERY:0,IQUERY:1,STATUS:2},ke={NOERROR:0,FORMERR:1,SERVFAIL:2,NXDOMAIN:3,NOTIMP:4,REFUSED:5};k.exports={DNS_TYPES:je,DNS_CLASSES:Ke,DNS_OPCODES:Ye,DNS_RCODES:ke}});var ee=d((On,Z)=>{var{encodeDomainName:Qe,parseFlags:Xe,encodeFlags:Ge}=Y(),{DNS_TYPES:Je,DNS_CLASSES:X}=Q();function G(e,t,n=1,r=0,o=0,s=0){let c=Buffer.alloc(12);return c.writeUInt16BE(e,0),c.writeUInt16BE(Ge(t),2),c.writeUInt16BE(n,4),c.writeUInt16BE(r,6),c.writeUInt16BE(o,8),c.writeUInt16BE(s,10),c}function Ze(e){return{transactionId:e.readUInt16BE(0),flags:Xe(e.readUInt16BE(2)),questionCount:e.readUInt16BE(4),answerCount:e.readUInt16BE(6),authorityCount:e.readUInt16BE(8),additionalCount:e.readUInt16BE(10)}}function J(e,t,n=X.IN){let r=Qe(e),o=Buffer.alloc(2),s=Buffer.alloc(2);return o.writeUInt16BE(t,0),s.writeUInt16BE(n,0),Buffer.concat([r,o,s])}function et(e,t={}){let n=e.map(c=>J(c.domain,c.type,c.class)),r=t.transactionId||Math.floor(Math.random()*65536),o=t.flags||{qr:0,opcode:0,aa:0,tc:0,rd:1,ra:0,z:0,rcode:0},s=G(r,o,e.length,0,0,0);return Buffer.concat([s,...n])}Z.exports={Encode:G,Decode:Ze,CreateDNSQuery:et,buildQuestion:J,DNS_TYPES:Je,DNS_CLASSES:X}});var oe=d((Rn,re)=>{var N={0:{name:"Echo Reply",restOfHeader:{description:"Identifier (2 bytes) + Sequence Number (2 bytes)",fields:[{name:"Identifier",size:2},{name:"Sequence Number",size:2}]}},3:{name:"Destination Unreachable",restOfHeader:{description:"Unused (4 bytes, set to zero)",fields:[{name:"Unused",size:4}]}},4:{name:"Source Quench",restOfHeader:{description:"Unused (4 bytes, set to zero)",fields:[{name:"Unused",size:4}]}},5:{name:"Redirect",restOfHeader:{description:"Gateway IP address (4 bytes)",fields:[{name:"Gateway IP",size:4}]}},8:{name:"Echo Request",restOfHeader:{description:"Identifier (2 bytes) + Sequence Number (2 bytes)",fields:[{name:"Identifier",size:2},{name:"Sequence Number",size:2}]}},11:{name:"Time Exceeded",restOfHeader:{description:"Unused (4 bytes, set to zero)",fields:[{name:"Unused",size:4}]}},12:{name:"Parameter Problem",restOfHeader:{description:"Pointer (1 byte) + Unused (3 bytes)",fields:[{name:"Pointer",size:1},{name:"Unused",size:3}]}},13:{name:"Timestamp Request",restOfHeader:{description:"Identifier (2 bytes) + Sequence Number (2 bytes)",fields:[{name:"Identifier",size:2},{name:"Sequence Number",size:2}]}},14:{name:"Timestamp Reply",restOfHeader:{description:"Identifier (2 bytes) + Sequence Number (2 bytes)",fields:[{name:"Identifier",size:2},{name:"Sequence Number",size:2}]}},15:{name:"Information Request",restOfHeader:{description:"Identifier (2 bytes) + Sequence Number (2 bytes)",fields:[{name:"Identifier",size:2},{name:"Sequence Number",size:2}]}},16:{name:"Information Reply",restOfHeader:{description:"Identifier (2 bytes) + Sequence Number (2 bytes)",fields:[{name:"Identifier",size:2},{name:"Sequence Number",size:2}]}}};function te(e){return N.hasOwnProperty(e)?N[e]:(console.warn(`\u26A0\uFE0F Unknown ICMP Type: ${e} \u2014 Rest of Header format undefined.`),null)}function ne(e,t){let n=te(e);if(!n)return!1;let r=n.restOfHeader.fields.reduce((o,s)=>o+s.size,0);return t.length!==r?(console.warn(`\u274C Invalid Rest of Header length for ICMP Type ${e} (${n.name}). Expected ${r} bytes, got ${t.length} bytes.`),!1):(console.log(`\u2705 Rest of Header is valid for ICMP Type ${e} (${n.name})`),!0)}var tt=8,nt=Buffer.from([18,52,0,1]);ne(tt,nt);function rt(e){let t=0;for(let n=0;n<e.length;n+=2){let r=(e[n]<<8)+(e[n+1]||0);for(t+=r;t>65535;)t=(t&65535)+(t>>>16)}return~t&65535}re.exports={ICMP_TYPE_MAP:N,validateICMPType:te,validateRestOfHeader:ne,calculateIcmpChecksum:rt}});var ce=d((Nn,se)=>{var{validateRestOfHeader:An,calculateIcmpChecksum:ot}=oe();function st(e,t,n=0,r=0,o=Buffer.alloc(0)){let s=Buffer.alloc(8+o.length);return s[0]=e,s[1]=t,s.writeUInt16BE(0,2),s.writeUInt16BE(n,4),s.writeUInt16BE(r,6),o.length>0&&o.copy(s,8),s.writeUInt16BE(ot(s),2),console.log(s,"HEader"),s}function ct(e){let t={};return t.type=e[0],t.code=e[1],t.checksum=e.readUInt16BE(2),t.identifier=e.readUInt16BE(4),t.sequence=e.readUInt16BE(6),t.data=e.slice(8),t}se.exports={Encode:st,Decode:ct}});var fe=d((vn,ie)=>{function it(e){if(!e||e.length===0)return Buffer.alloc(0);let t=[];for(let o of e)if(o.type==="EOL"){t.push(Buffer.from([0]));break}else if(o.type==="NOP")t.push(Buffer.from([1]));else if(o.type==="RR"){let s=o.length||7;if(s<7||s>39||(s-3)%4!==0)throw new Error(`Invalid RR length: ${s}. Must be 3 + 4n where 1 <= n <= 9`);let c=Buffer.alloc(s);c[0]=7,c[1]=s,c[2]=4,t.push(c)}else if(o.type==="LSRR"){let s=o.length||7;if(s<7||s>39||(s-3)%4!==0)throw new Error(`Invalid LSRR length: ${s}. Must be 3 + 4n where 1 <= n <= 9`);let c=Buffer.alloc(s);c[0]=131,c[1]=s,c[2]=4,t.push(c)}else if(o.type==="SSRR"){let s=o.length||7;if(s<7||s>39||(s-3)%4!==0)throw new Error(`Invalid SSRR length: ${s}. Must be 3 + 4n where 1 <= n <= 9`);let c=Buffer.alloc(s);c[0]=137,c[1]=s,c[2]=4,t.push(c)}else if(o.type==="TS"){let s=o.length||12;if(s<8||s>40||s%4!==0)throw new Error(`Invalid TS length: ${s}. Must be multiple of 4, between 8-40`);let c=Buffer.alloc(s);c[0]=68,c[1]=s,c[2]=5,c[3]=o.flags||0,t.push(c)}else if(o.type==="RAW"){if(!Buffer.isBuffer(o.data))throw new Error("RAW option requires a Buffer in .data");if(o.data.length===0)continue;t.push(o.data)}else throw new Error(`Unsupported option type: ${o.type}`);let n=Buffer.concat(t),r=(4-n.length%4)%4;if(r>0&&(n=Buffer.concat([n,Buffer.alloc(r)])),n.length>40)throw new Error("Total options length exceeds maximum (40 bytes)");return n}function ft(e,t){if(typeof e!="string")throw new Error("Flags must be a string");let n=0,r=e.toLowerCase();if(r.includes("df")&&(n|=2),r.includes("mf")&&(n|=1),t<0||t>8191)throw new Error("Fragment offset must be 0-8191");return n<<13|t&8191}function ut(e){let t={icmp:1,igmp:2,tcp:6,egp:8,pup:12,udp:17,ipv6:41,ospf:89,sctp:132,udplite:136},n=e.toLowerCase();if(!(n in t))throw new Error(`Invalid protocol: ${e}. Supported: ${Object.keys(t).join(", ")}`);return t[n]}function at(e){let t=0;for(let n=0;n<e.length;n+=2){let r;for(n+1<e.length?r=e[n]<<8|e[n+1]:r=e[n]<<8,t+=r;t>65535;)t=(t&65535)+(t>>>16)}return~t&65535}function lt(e){if(typeof e!="string")throw new Error("IP address must be a string");let t=e.split(".");if(t.length!==4)throw new Error(`Invalid IP address format: ${e}`);let n=t.map(r=>parseInt(r,10));for(let r=0;r<4;r++)if(isNaN(n[r])||n[r]<0||n[r]>255)throw new Error(`Invalid IP octet: ${t[r]} in ${e}`);return(n[0]<<24|n[1]<<16|n[2]<<8|n[3])>>>0}function dt(e){let{version:t,DSCP:n,ECN:r,identification:o,fragmentOffset:s,ttl:c,payload:i}=e;if(t!==4)throw new Error("Only IPv4 (version 4) is supported");if(n<0||n>63)throw new Error("DSCP must be 0-63");if(r<0||r>3)throw new Error("ECN must be 0-3");if(o<0||o>65535)throw new Error("Identification must be 0-65535");if(s<0||s>8191)throw new Error("Fragment offset must be 0-8191");if(c<0||c>255)throw new Error("TTL must be 0-255");if(!Buffer.isBuffer(i))throw new Error("Payload must be a Buffer")}ie.exports={processOptions:it,processFlagsAndOffset:ft,processProtocol:ut,onesComplementSum:at,processIP:lt,validateParameters:dt}});var ae=d((Cn,ue)=>{function Bt(e,t=0){return Buffer.isBuffer(e)?e.length<t+2?(console.warn("[checkAndRead16] Buffer too short for 16-bit field"),0):e.readUInt16BE(t):(console.warn("[checkAndRead16] Packet must be a Buffer"),0)}function pt(e,t=0){return Buffer.isBuffer(e)?e.length<t+1?(console.warn("[checkAndRead8] Buffer too short for 8-bit field"),0):e.readUInt8(t):(console.warn("[checkAndRead8] Packet must be a Buffer"),0)}function ht(e,t,n=0){return Buffer.isBuffer(e)?e.length<n+2?(console.warn("[checkAndWrite16] Buffer too short for 16-bit field"),0):t<0||t>65535||!Number.isInteger(t)?(console.warn("[checkAndWrite16] Value out of 16-bit unsigned range"),0):(e.writeUInt16BE(t,n),2):(console.warn("[checkAndWrite16] Packet must be a Buffer"),0)}function It(e,t,n=0){return Buffer.isBuffer(e)?e.length<n+1?(console.warn("[checkAndWrite16] Buffer too short for 8-bit field"),0):t<0||t>255||!Number.isInteger(t)?(console.warn("[checkAndWrite16] Value out of 8-bit unsigned range"),0):(e.writeUInt8(t,n),1):(console.warn("[checkAndWrite16] Packet must be a Buffer"),0)}ue.exports={checkAndRead16:Bt,checkAndWrite16:ht,checkAndRead8:pt,checkAndWrite8:It}});var de=d((Hn,H)=>{var{processOptions:mt,processFlagsAndOffset:wt,processProtocol:Et,onesComplementSum:gt,processIP:le,validateParameters:Ut}=fe(),{checkAndRead16:O,checkAndWrite16:x,checkAndRead8:E,checkAndWrite8:R}=ae();function v(e,t,n,r,o,s,c,i,f,u,m,p){Ut({version:n,DSCP:r,ECN:o,identification:s,fragmentOffset:i,ttl:f,payload:p});let l=Buffer.alloc(20),B=mt(m),S=20+B.length,F=S/4;if(F>15)throw new Error("Options too large (max 40 bytes)");if(F!==Math.floor(F))throw new Error("Invalid options length (must be multiple of 4)");let b=S+p.length;if(b>65535)throw new Error("Packet exceeds maximum IPv4 size (65535 bytes)");let y=wt(c,i),A=Et(u);R(l,n<<4|F&15,0),R(l,r<<2|o,1),x(l,b,2),x(l,s,4),x(l,y,6),R(l,f,8),R(l,A,9),x(l,0,10),l.writeUInt32BE(le(e),12),l.writeUInt32BE(le(t),16);let Te=gt(Buffer.concat([l,B]));return x(l,Te,10),Buffer.concat([l,B,p])}function C(e){if(!Buffer.isBuffer(e)||e.length<20)throw new Error("Invalid packet: must be a Buffer with at least 20 bytes");let t=E(e,0),n=t>>4&15,r=t&15,o=r*4;if(n!==4)throw new Error("Not an IPv4 packet");if(o<20||o>60)throw new Error("Invalid IHL (header length)");if(e.length<o)throw new Error("Buffer shorter than header length");let s=E(e,1),c=s>>2&63,i=s&3,f=O(e,2);if(f<o||f>e.length)throw new Error("Total-length field exceeds actual buffer");let u=O(e,4),m=O(e,6),p=m>>13&7,l=m&8191,B=E(e,8),S=E(e,9),F=O(e,10),b=[E(e,12),E(e,13),E(e,14),E(e,15)].join("."),y=[E(e,16),E(e,17),E(e,18),E(e,19)].join(".");return{version:n,IHL:r,headerLength:o,DSCP:c,ECN:i,totalLength:f,identification:u,flags:{DF:!!(p&2),MF:!!(p&1)},fragmentOffset:l,ttl:B,protocol:S,checksum:F,srcIp:b,destIp:y,hasOptions:r>5,optionsLength:o-20}}if(L.main===H){console.log(`IPv4 Packet Encoder - Example Usage
`);let e=Buffer.from("Hello, IPv4 World!","utf8"),t=v("192.168.1.100","8.8.8.8",4,0,0,54321,"df",0,64,"tcp",[],e);console.log("Encoded Packet:"),console.log("Length:",t.length,"bytes"),console.log("Hex:",t.toString("hex")),console.log(`
Decoded Header:`),console.log(C(t)),console.log(`
--- Packet with Record Route Option ---
`);let n=v("10.0.0.1","10.0.0.2",4,0,0,12345,"",0,128,"udp",[{type:"RR",length:11}],e);console.log("Encoded Packet with Options:"),console.log("Length:",n.length,"bytes"),console.log("Hex:",n.toString("hex")),console.log(`
Decoded Header:`),console.log(C(n))}H.exports={Encode:v,Decode:C}});var pe=d((qn,Be)=>{function Ft(e){let t=e.split("::"),n=t[0]?t[0].split(":"):[],r=t[1]?t[1].split(":"):[],o=8-(n.length+r.length),s=[...n.map(i=>i.padStart(4,"0")),...Array(o).fill("0000"),...r.map(i=>i.padStart(4,"0"))],c=Buffer.alloc(16);for(let i=0;i<8;i++){let f=parseInt(s[i],16);c.writeUInt16BE(f,i*2)}return c}function bt(e){let t=[];for(let n=0;n<8;n++){let r=e.readUInt16BE(n*2);t.push(r.toString(16))}return t.join(":")}Be.exports={expandIPv6:Ft,bufferToIP:bt}});var we=d((Ln,me)=>{var{expandIPv6:he,bufferToIP:Ie}=pe();function St(e,t,n,r,o,s,c,i){let f=Buffer.alloc(40),u=6,m=n<<2|r,p=u<<28|m<<20|s&1048575;return f.writeUInt32BE(p,0),f.writeUInt16BE(o.length,4),f.writeUInt8(c,6),f.writeUInt8(i,7),he(e).copy(f,8),he(t).copy(f,24),Buffer.concat([f,o])}function yt(e){let t={4:"ipv4",6:"ipv6"},n={},r=e.readUInt32BE(0),o=r>>20&255;return n.Version=t[r>>28],n.DSCP=o>>2&63,n.ECN=o&3,n.flowLabel=r&1048575,n.payloadLength=e.readUInt16BE(4),n.nextHeader=e.readUInt8(6),n.hopLimit=e.readUInt8(7),n.sourceAddr=Ie(e.slice(8,24)),n.destinationAddr=Ie(e.slice(24,40)),n.payload=e.slice(40),n}me.exports={Encode:St,Decode:yt}});var P=d((Dn,Ee)=>{function xt(){return Buffer.from([0])}function Pt(){return Buffer.from([1])}function Ot(e){let t=Buffer.alloc(4);return t[0]=2,t[1]=4,t.writeUInt16BE(e,2),t}function Rt(e){let t=Buffer.alloc(3);return t[0]=3,t[1]=3,t[2]=e&255,t}function At(){return Buffer.from([4,2])}function Nt(e=4294967295,t=0){let n=Buffer.alloc(10);return n[0]=8,n[1]=10,n.writeUInt32BE(e>>>0,2),n.writeUInt32BE(t>>>0,6),n}function vt(e){let t=e.length%4;if(t===0)return e;let n=4-t;return Buffer.concat([e,Buffer.alloc(n,1)])}Ee.exports={optEOL:xt,optNOP:Pt,optMSS:Ot,optWScale:Rt,optSACK:At,optTimestamp:Nt,optPadding:vt}});var T=d((_n,Ue)=>{function ge(e){return Buffer.from(e.split(".").map(t=>parseInt(t,10)))}function Ct(e,t,n){let r=Buffer.alloc(12);ge(e).copy(r,0),ge(t).copy(r,4),r.writeUInt8(0,8),r.writeUInt8(6,9),r.writeUInt16BE(n.length,10);let c=Buffer.concat([r,n]);return~Ht(c)&65535}function Ht(e){let t=0;for(let n=0;n<e.length;n+=2){let r;for(n+1<e.length?r=(e[n]<<8)+e[n+1]:r=e[n]<<8,t+=r;t>65535;)t=(t&65535)+(t>>>16)}return t}Ue.exports={tcpCheckSum:Ct}});var be=d(($n,Fe)=>{var{optEOL:Mn,optNOP:g,optMSS:h,optWScale:I,optSACK:w,optTimestamp:U,optPadding:a}=P(),Tt=a(Buffer.concat([I(10),g(),h(1460),U(4294967295,0),w()])),qt=a(Buffer.concat([h(265),w(),U(4294967295,0),g(),I(15)])),Lt=a(Buffer.concat([I(10),g(),h(1400),U(4294967295,0),w()])),Dt=a(Buffer.concat([U(4294967295,0)])),_t=Buffer.alloc(0),Mt=Buffer.alloc(0),$t=Buffer.alloc(0),zt=a(Buffer.concat([I(10),g(),h(1460),w(),g(),g()])),Wt=a(Buffer.concat([h(1460)])),Vt=a(Buffer.concat([I(7)])),jt=a(Buffer.concat([w()])),Kt=a(Buffer.concat([U()])),Yt=a(Buffer.concat([h(1460),I(7),w(),U()])),kt=a(Buffer.concat([U(),w(),I(7),h(1460)])),Qt=a(Buffer.concat([h(536),w()])),Xt=a(Buffer.concat([h(65535),I(0)])),Gt=a(Buffer.concat([I(0),h(1460)])),Jt=a(Buffer.concat([I(14),w()])),Zt=a(Buffer.concat([I(16),h(1200)])),en=a(Buffer.concat([U(0,0),h(1460)])),tn=a(Buffer.concat([U(1,0),w()])),nn=Buffer.concat([h(1460),I(7),w(),U(4294967295,0),Buffer.alloc(21,1)]),rn=a(Buffer.concat([g()])),on=a(Buffer.concat([h(1460),w(),U(),g(),I(7)])),sn=a(Buffer.concat([h(1460),g(),I(8),g(),g(),w()])),cn=a(Buffer.concat([h(1460),g(),I(6),w(),U()]));Fe.exports={T1_options:Tt,T2_options:qt,T3_options:Lt,T4_options:Dt,T5_options:_t,T6_options:Mt,T7_options:$t,ECN_options:zt,MSS_only:Wt,WSCALE_only:Vt,SACK_only:jt,TIMESTAMP_only:Kt,ALL_options_v1:Yt,ALL_options_v2:kt,UNUSUAL_MSS_1:Qt,UNUSUAL_MSS_2:Xt,UNUSUAL_WSCALE_1:Gt,UNUSUAL_WSCALE_2:Jt,INVALID_WSCALE:Zt,TIMESTAMP_zero:en,TIMESTAMP_small:tn,MAX_options:nn,MIN_options:rn,LINUX_probe:on,WINDOWS_probe:sn,BSD_probe:cn}});var q=d((zn,Se)=>{var{optPadding:fn}=P(),{tcpCheckSum:un}=T();function an(e,t,n,r,o=0,s=0,c={},i=65535,f=0,u=Buffer.alloc(0),m=Buffer.alloc(0)){let p=fn(u,"options"),l=20+p.length,B=Buffer.alloc(l);B.writeUInt16BE(n,0),B.writeUInt16BE(r,2),B.writeUInt32BE(o,4),B.writeUInt32BE(s,8);let F=l/4<<12,b=(c.fin?1:0)|(c.syn?2:0)|(c.rst?4:0)|(c.psh?8:0)|(c.ack?16:0)|(c.urg?32:0)|(c.ece?64:0)|(c.cwr?128:0);B.writeUInt16BE(F|b,12),B.writeUInt16BE(i,14),B.writeUInt16BE(f,18),p.length>0&&p.copy(B,20);let y=Buffer.concat([B,m]),A=un(e,t,y);return B.writeUInt16BE(A,16),Buffer.concat([B,m])}function ln(e,t=!1){if(!Buffer.isBuffer(e))return console.warn("Packet must be a Buffer"),Buffer.alloc(0);let n=t?20:0,r=n+20;if(e.length<r)return console.warn("Packet too small for TCP header"),Buffer.alloc(0);let o={};o.sourcePort=e.readUInt16BE(n+0),o.destinationPort=e.readUInt16BE(n+2),o.sequenceNumber=e.readUInt32BE(n+4),o.acknowledgmentNumber=e.readUInt32BE(n+8);let s=e.readUInt8(n+12),c=s>>4&15;if((s&14)!==0)return console.warn("Non-zero reserved bits detected"),Buffer.alloc(0);let f=e.length-n;if(!hn(c,f))return Buffer.alloc(0);o.dataOffset=c,o.flags=dn(e.readUInt8(n+13)),o.windowSize=e.readUInt16BE(n+14),o.checksum=e.readUInt16BE(n+16),o.urgentPointer=e.readUInt16BE(n+18);let u=c*4;if(u>20){let m=u-20,p=e.slice(n+20,n+20+m);o.options=Bn(p)}else o.options=[];return o.dataPayload=e.slice(n+u),o}function dn(e){let t=e.toString(2).padStart(8,"0");return["CWR","ECE","URG","ACK","PSH","RST","SYN","FIN"].filter((r,o)=>t[o]==="1")}function Bn(e){if(!Buffer.isBuffer(e))return console.warn("Options must be a Buffer"),[];let t={0:"EOL",1:"NOP",2:"MSS",3:"WS",4:"SACK-Permitted",5:"SACK",8:"Timestamps",14:"AltChkSum",15:"AltChkSumData"},n={2:4,3:3,4:2,5:10,8:10,14:3,15:2},r={2:4,3:3,4:2,5:34,8:10,14:3,15:40},o=[],s=0;for(;s<e.length;){let c=e[s];if(c===0){o.push({type:"EOL",kind:0});break}if(c===1){o.push({type:"NOP",kind:1}),s++;continue}if(s+1>=e.length){console.warn(`Option kind ${c} missing length byte at position ${s}`);break}let i=e[s+1];if(pn(c,i,s,e.length,n,r,t))return[];let f=e.slice(s+2,s+i);o.push({type:t[c]||`Unknown-${c}`,kind:c,length:i,data:f}),s+=i}return o}function pn(e,t,n,r,o,s,c){return t<2?(console.warn(`Option kind ${e} has invalid length ${t} (minimum is 2)`),!0):o[e]&&t<o[e]?(console.warn(`Option kind ${e} length ${t} is below minimum ${o[e]}`),!0):s[e]&&t>s[e]?(console.warn(`Option kind ${e} length ${t} exceeds maximum ${s[e]}`),!0):n+t>r?(console.warn(`Option kind ${e} extends beyond buffer bounds`),!0):!c[e]&&t>40?(console.warn(`Unknown option kind ${e} has excessive length ${t}`),!0):e===5&&(t-2)%8!==0?(console.warn(`SACK option has invalid length ${t} (must be 2 + 8n bytes)`),!0):!1}function hn(e,t){let n=e*4;return n<20||n>60?(console.warn(`Invalid data offset: ${e} (header length: ${n} bytes)`),!1):t<n?(console.warn(`Packet size ${t} is smaller than header length ${n}`),!1):!0}Se.exports={Encode:an,Decode:ln,OptionBuilders:P(),Probes:be(),TCPChecksum:T()}});var xe=d((Wn,ye)=>{function In(e,t,n){let r=Buffer.alloc(12);return e.split(".").forEach((o,s)=>{r[s]=parseInt(o,10)}),t.split(".").forEach((o,s)=>{r[s+4]=parseInt(o,10)}),r[8]=0,r[9]=17,r.writeUInt16BE(n,10),r}function mn(e,t,n){let r=Buffer.concat([e,t,n]),o=0;for(let s=0;s<r.length;s+=2){let c=(r[s]<<8)+(r[s+1]||0);for(o+=c;o>65535;)o=(o&65535)+(o>>>16)}return~o&65535}ye.exports={buildPseudoHeader:In,calculateChecksum:mn}});var Ae=d((Vn,Re)=>{var{buildPseudoHeader:Pe,calculateChecksum:Oe}=xe();function wn(e,t,n,r,o=Buffer.alloc(0)){let s=Buffer.alloc(8);s.writeUInt16BE(n,0),s.writeUInt16BE(r,2),s.writeUInt16BE(8+o.length,4),o.length%2!==0&&console.warn(`[UDP Security] Odd-length payload (${o.length} bytes) may leak memory when sent via raw sockets. Consider padding to even length.`);let c=Pe(e,t,8+o.length),i=Oe(c,s,o);return s.writeUInt16BE(i,6),Buffer.concat([s,o])}function En(e,t=!1){let n={},r=t?20:0,o=e.length-r;return o<8?(console.warn(`[UDP Decode] Packet too small: need 8 bytes for header, got ${o} bytes.`),null):(n.SourcePort=e.readUInt16BE(r),n.destinationPort=e.readUInt16BE(r+2),n.length=e.readUInt16BE(r+4),n.checksum=e.readUInt16BE(r+6),o<n.length&&console.warn(`[UDP Decode] Packet truncated: expected ${n.length} bytes, got ${o} bytes.`),n.data=e.slice(r+8,r+n.length),n)}Re.exports={Encode:wn,Decode:En,pseudoHeader:Pe,checksum:Oe}});var Ce=d((jn,ve)=>{var Ne=q();function gn(e,t,n=0,r=0,o,s,c){let i=c.length,f=Buffer.alloc(5);f.writeUInt8(o,0),f.writeUInt16BE(s,1),f.writeUInt16BE(i,3);let u=Buffer.concat([f,c]);return Ne.Encode(e,t,51723,443,n,r,{psh:!0,ack:!0},65535,0,Buffer.alloc(0),u)}function Un(e){let t=Ne.Decode(e),n=t.dataPayload,r={};return r.contentType=n.readUInt8(0),r.protocolVersion=n.readUInt16BE(1),r.length=n.readUInt16BE(3),r.payload=n.slice(5,5+r.length),{tcp:t,tls:r}}ve.exports={Encode:gn,Decode:Un}});var Fn=d((Kn,He)=>{He.exports={arp:j(),dns:ee(),icmp:ce(),ipv4:de(),ipv6:we(),tcp:q(),udp:Ae(),tls:Ce(),optionBuilder:P()}});Fn();})();
